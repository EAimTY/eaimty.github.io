<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=#000000 id=color_chrome name=theme-color><meta content=#000000 id=color_safari name=apple-mobile-web-app-status-bar-style><meta content="EAimTY's Blog" name=description><link rel="Shortcut Icon" href=https://www.eaimty.com/favicon.ico><link href=https://www.eaimty.com/favicon.ico rel=Bootmark><link title="EAimTY's Blog" href=https://www.eaimty.com/rss.xml rel=alternate type=application/rss+xml><style>#title,body{line-height:1.6em}body{background:#000;color:#00c000;font-size:1.2em}#container{margin:2.4em auto;width:72%}#header{text-align:center}#header>a{font-size:.96em;margin:auto 1em}#title{font-size:1.6em;font-weight:700;margin:1em auto}#date{font-style:italic}#list>li{margin:.8em auto;list-style:disc}img{max-width:100%}a{color:inherit;text-decoration:none}#content a,a:hover{text-decoration:underline}pre{padding:1em;overflow:auto;background:#1b1d16}:not(pre) >code{padding:.2em;background:#1b1d16;overflow:auto}blockquote{padding:0 1em;margin:0;border-left:.25em solid #212121}@media (max-width:600px){#container{width:88%}#header>a{margin:auto .3em}}</style><title>HashMap，以及没有 hash 的 HashMap - EAimTY's Blog</title><body><div id=header><a href=https://www.eaimty.com>EAimTY's Blog</a><a href=https://www.eaimty.com/about/>About</a><a href=https://www.eaimty.com/friends/>Friends</a></div><div id=container><a href=https://www.eaimty.com/2021/how-hashmap-work-without-hash/ id=title>HashMap，以及没有 hash 的 HashMap</a><div id=date>2022-03-04</div><div id=content><p>我之前对 HashMap 有很多错误的理解，特别是在 hash 函数对性能的影响上。最近我对 HashMap 的了解稍稍深入了一些，所以写了这篇笔记，对之前的错误理解修正总结。<h1 id=tou-ming-de-hash-han-shu>“透明”的 hash 函数</h1><p>首先从 hash 函数说起。 在我之前的理解中，hash 的用处就是：<ul><li>能根据一个任何（支持被 hash）类型的值计算出一个无符号整数<li>对于两个相同的值，hash 出的值必须相等<li>对于两个不同的值，hash 出的值必须有极大概率（接近 100%）不同，也就是碰撞概率要低</ul><p>确实，上面这三点是任何一个 hash 函数都需要具备的。按照这种理解，可以发现一个有趣的事情：<p>如果一个 HashMap 的键刚好是一个 <strong>64 位无符号整数</strong>，或者是 <strong>能 cast 为 64 位无符号整数的类型</strong>，那它岂不是不需要进行 hash 操作就可以满足上面的三点？<p>大量的数据都符合这一条件，例如 UID（从 0 起不断增大的无符号整数）和时间戳。<p>大概很多人都有过这种想法，举个例子：<a href=https://github.com/paritytech/nohash-hasher>NoHashHasher</a>。我之前在逛 <a href=https://www.reddit.com/r/rust/>r/rust</a> 的时候发现了这个库。简单来说，就是针对整数构造一个 hash 函数，将输入的值直接输出。也就是说，我们可以零成本地利用整数作为 HashMap 的键，在能得到 HashMap 平均 <code>O(1)</code> 的查找效率的同时不需要将性能浪费在 hash 函数上！<p>然而事实并非如此，用整数省略 hash 过程可能会让 HashMap 的性能低很多，这与 HashMap 的内部实现有关。<h1 id=hashmap-hashset-de-shi-xian>HashMap（HashSet） 的实现</h1><p>HashMap 和 HashSet 之间唯一的区别就是，HashSet 只存键，HashMap 存键和值（每个键和对应的值是放在一起的，完全可以看作一个 tuple），所以下面都用 HashSet 描述。HashSet 的实现有很多，这里简单描述三个。<h2 id=c-stl-zhong-de-unordered-set>C++ STL 中的 <a href=https://gcc.gnu.org/onlinedocs/gcc-11.2.0/libstdc++/api/a00365_source.html>unordered_set</a></h2><p>STL 没有实现标准，但是对 HashTable 的实现都大同小异，比如 GCC 的实现。<p>简单来说，就是一块长度为 n 个指针的内存作为 HashSet 的索引，每个指针都指向一个链表，链表里之后要存放的是元素的 hash 值和元素本身。操作时，计算要操作元素的 hash 值，用得到的值模除 n，得到这个元素应该放在这个索引中的哪个位置指向的链表中，然后去链表中执行相应的操作。扩容时，只需要为新节点分配内存，不需要动旧节点的位置。<p>上面的描述简化了 rehash、链表前导元素等很多细节，不过这些不重要，<strong>hash 值模除索引的长度</strong> 和 <strong>扩容时不需要移动旧节点</strong> 是关键。<h2 id=robin-hood-unordered-set><a href=https://github.com/martinus/robin-hood-hashing>robin_hood::unordered_set</a></h2><p>这是一个很常用的 HashTable 实现，因为性能好，很多人用它代替 STL 的实现。Rust 在 1.36 版本之前的标准库 HashMap 实现也是这个。<p><code>robin_hood::unordered_set</code> 有 <code>node</code> 和 <code>flat</code> 两种布局，<code>node</code> 是类似于 STL 版本的链表实现，<code>flat</code> 顾名思义是 probing table 的布局，把元素直接放进一个连续的，类似 vector 的结构。在不考虑容量时 vector 几乎每一项性能都肯定比链表强，因此这个表的实现当然比 STL 版本性能好。<p>用 STL 版本类比，<code>robin_hood</code> 版就相当于把链表放进了 vector，因此“链表”的最大长度是有限的，只要有任意一个“hash 值模除分段（也就是上面的“链表”）个数“对应的段满了就需要扩容，扩容时需要把每一段增大并依次向内存后部平移，因此开销很大。<p>上面的描述同样简化了很多细节，不过这些也不重要，<strong>hash 值模除分段个数</strong> 和 <strong>扩容时需要移动旧节点，开销大</strong> 是关键。<h2 id=swisstable><a href=https://abseil.io/blog/20180927-swisstables>SwissTable</a></h2><p>这是一个新的高性能 HashTable 实现，Rust 在 1.36 版本之后的标准库实现就是这个。<p>与 <code>robin_hood::unordered_map</code> 的 <code>flat</code> 布局类似，SwissTable 也把值存在连续的内存中，但在查找时并不直接到存放元素的内存部分查，而是建立一个“索引”标识每个内存位置的状态，先到“索引”中查找。<p>通过这个实现可以理解 hash 值对表性能的影响为什么很大，所以要详细描述一下。当然还是忽略如 Group 之类的无关细节。<p>建立 HashSet 时，SwissTable 创建了两个类似 vector 的结构，一个是索引表，一个是数据表。两个表的长度一致，对应位置数据之间是相关联的。数据表中存放的是插入 HashSet 的数据本身，索引表中存放的是 1 bit 标识这个位置是否是空位，以及数据 hash 值的后 7 bit，加起来正好是 1 字节。表被分成 n 段，每段中存放的是 hash 值的前 57 bit 模除 n 后结果相同的值。<p>在操作元素时：<ol><li>计算需要操作的元素的 hash 值<li>取 hash 值的前 57 bit 模除 n 得到应该在表的第几分段<li>前往索引表的这个分段，查找所存储的值与 hash 值的后 7 bit 一致，以及另外那 1 bit 标识不是空位的位置<li>这时，hash 值的前 57 bit 取模后的值，以及后 7 bit 都已经与需要操作的元素对应了，直接到数据表的对应位置操作数据即可</ol><p>SwissTable 的设计实在是太精妙了，虽然在这篇文章的主题以外，但还是推荐去看一下 SwissTable 的实现，它能将操作所需的几乎所有数据都放进 L1 缓存，并且通过分组操作实现 SIMD 加速。<p>跑题了，总之 SwissTable 的重点是 <strong>用 hash 的前 57 bit 确定分组位置，后 7 bit 确定元素位置</strong>，以及与 robin_hood flat 实现一样的 <strong>扩容时需要移动旧节点，开销大</strong>。<p>准备工作完成，终于可以来解答为什么“透明”的 hash 函数不一定好了。<h1 id=bu-shi-suo-you-zheng-shu-du-shi-ping-deng-de>不是所有整数都是平等的</h1><p>利用之前提到“透明”的 hash 函数，假设有这些数据要插入一个分段数刚好是 100 的 HashTable 中：<p>100、300、1400、2500、40600、79137500<p>这些值看似都符合最早提到的对 hash 值的要求，然而模除后所有的余数都是 0，全部都碰撞了。当然这只是极端情况，一般来说 HashTable 的分段数都是 2 的幂。 举这个例子是为了说明：只有当作为键的数模除表分段数 n 的结果在 0 到 n 间均匀散布时， HashTable 的效率才是最高的。不经过 hash 处理的数据很难达到这个要求。<p>那假如要插入的数据如下（都是 8 位无符号整数）：<p>0、1、2、3、4、5、6、7、...、255<p>这组数据确实符合唯一且分布均匀的要求，只要把把这些 8 位无符号整数 cast 成 64 位无符号整数就可以直接作为 hash 值使用？<p>对于 STL 中的 <code>std::unordered_set</code> 和 <code>robin_hood::unordered_set</code>，确实可以直接作为 hash 值使用。但是对于 SwissTable 就不可以了。把上面这些数加上前导 0 扩充到 64 位，取前 57 位拿来模除，后 7 位放进索引表，会出现一个问题：这些数的前 57 位要么是 0，要么是 1，只有这两种情况，再次出现了非常严重的碰撞。<p>有什么解决方法吗？当然有：<pre><code>n = (n >> 1) | (n << 7)
</code></pre><p>但这也不完美，因为这样 <code>(n >> 1)</code> 就成了索引表中的数据，0 和 1，2 和 3，4 和 5，...，254 和 255 在索引表中的数据变成了一样的，产生了碰撞。<h1 id=zong-jie>总结</h1><p>综上，同样的 hash 值，在不同的 HashMap 实现中的性能可能相差巨大。就算是根据统一思路实现的 HashMap，在实现细节上有细微差距，也会导致性能相差悬殊，举个例子：Rust 1.36 后标准库中的 HashTable 采用了 SwissTable，但两者在实现上有一点非常小的区别：原版 SwissTable 将低 7 位放入索引表，而 Rust 实现是将高 7 位放入索引表。这一点微小的不同，就可能会让你本来调教好的“透明” hash 出现严重的碰撞。大量的碰撞意味着大量的扩容，在时间和空间上都会造成浪费。<p>当然，如果你的数据是：<ul><li>已经 hash 过的数<li>或是保证在 0 到 18446744073709551615(uint64::MAX) 间均匀分布</ul><p>用“透明” hash 完全没有问题。<p>所以，除非完全搞懂了要用的 HashMap 实现，否则不要用“透明” hash。对于现代的处理器，对数字进行 hash 几乎可以说是 free 的。<p>hash 的作用到底是什么？<ul><li>能根据一个任何（支持被 hash）类型的值计算出一个无符号整数<li>对于两个相同的值，hash 出的值必须相等<li>对于两个不同的值，hash 出的值必须有极大概率（接近 100%）不同，也就是碰撞概率要低<li>hash 出的值要分布均匀，从而避免在数据结构上的碰撞</ul><p>最后推荐一个视频：<a href=https://youtu.be/ncHmEUmJZf4>CppCon 2017: Matt Kulukundis “Designing a Fast, Efficient, Cache-friendly Hash Table, Step by Step”</a> 这是 SwissTable 作者之一在 CppCon 2017 分享如何从 <code>std::unordered_set</code> 一步步优化最后得到 SwissTable，知识密度很高，非常棒的分享。</div><div id=comments-issue-id style=display:none>50</div><style>#comment-header,#comment-list>li{margin:1em auto}#comment-avatar,#comment-tip{margin:auto .2em}#comment-action-avatar,#comment-avatar{width:1em;height:1em}#comment-action-info>*,#comment-action-input>*,#comment-info>*{display:inline-block;vertical-align:middle}#comment-header{font-size:1.6em;font-weight:700;line-height:1.6em}#comment-tip{font-style:italic}#comment-list{list-style:none;padding:0}#comment-action-author,#comment-author{font-weight:700;margin:auto .4em}#comment-datetime{font-size:.8em;font-style:italic}#comment-body{margin:auto 1.8em}#comment-action-info>*{margin:1em .2em}#comment-action-input{height:2em;width:100%;margin:1em auto}#comment-action-input>*{height:100%;margin:0 .2em}#comment-action-textarea{width:calc(100% - 8em)}#comment-action-post{width:6em}#comment-action-login{margin:1em .3em}</style><ol id=comment-list></ol><div id=comment-action></div><script>const y=e=>{var t=/\\([\\\|`*_{}\[\]()#+\-~])/g,n=/\n *&gt; *([^]*?)(?=(\n|$){2})/g,i=/\n( *)(?:[*\-+]|((\d+)|([a-z])|[A-Z])[.)]) +([^]*?)(?=(\n|$){2})/g,o=/(^|[^A-Za-z\d\\])(([*_])|(~)|(\^)|(--)|(\+\+)|`)(\2?)([^<]*?)\2\8(?!\2)(?=\W|_|$)/g,a=/^.*\n( *\|( *:?-+:?-+:? *\|)* *\n|)/,c=/.*\n/g,m=/\||(.*?[^\\])\|/g;const l=(t,n)=>{e=e.replace(t,n)},d=(e,t)=>"<"+e+">"+t+"</"+e+">",r=e=>e.replace(n,((e,t)=>d("blockquote",r(u(t.replace(/^ *&gt; */gm,"")))))),s=e=>e.replace(i,((e,t,n,i,o,a)=>(e=d("li",u(a.split(RegExp("\n ?"+t+"(?:(?:\\d+|[a-zA-Z])[.)]|[*\\-+]) +","g")).map(s).join("</li><li>"))),"\n"+(n?'<ol start="'+(i?n+'">':parseInt(n,36)-9+'" style="list-style-type:'+(o?"low":"upp")+'er-alpha">')+e+"</ol>":d("ul",e))))),u=e=>e.replace(o,((e,t,n,i,o,a,c,m,l,r)=>t+d(i?l?"strong":"em":o?l?"s":"sub":a?"sup":c?"small":m?"big":"code",u(r))));var p=[],h=0;return e="\n"+e+"\n",l(/</g,"&lt;"),l(/>/g,"&gt;"),l(/\t|\r|\uf8ff/g,"  "),e=r(e),l(/^([*\-=_] *){3,}$/gm,"<hr/>"),e=s(e),l(/<\/(ol|ul)>\n\n<\1>/g,""),l(/\n((```|~~~).*\n?([^]*?)\n?\2|((    .*?\n)+))/g,((e,t,n,i,o)=>(p[--h]=d("pre",d("code",i||o.replace(/^    /gm,""))),h+""))),l(/((!?)\[(.*?)\]\((.*?)( ".*")?\)|\\([\\`*_{}\[\]()#+\-.!~]))/g,((e,n,i,o,a,c,m)=>(p[--h]=a?i?'<img src="'+a+'" alt="'+o+'"/>':'<a href="'+a+'">'+u(o).replace(t,"$1")+"</a>":m,h+""))),l(/&lt;(.*?)&gt;/g,((e,n)=>'<a href="'+n+'">'+u(n).replace(t,"$1")+"</a>")),l(/\n(( *\|.*?\| *\n)+)/g,((e,n)=>{var i=n.match(a)[1];return"\n"+d("table",n.replace(c,((e,n)=>e==i?"":d("tr",e.replace(m,((e,o,a)=>a?d(i&&!n?"th":"td",u(o||"").replace(t,"$1")):""))))))})),l(/(?=^|>|\n)([>\s]*?)(#{1,6}) (.*?)( #*)? *(?=\n|$)/g,((e,n,i,o)=>n+d("h"+i.length,u(o).replace(t,"$1")))),l(/(?=^|>|\n)\s*\n+([^<]+?)\n+\s*(?=\n|<|$)/g,((e,n)=>d("p",u(n).replace(t,"$1")))),l(/-\d+\uf8ff/g,(e=>p[parseInt(e,10)])),e.trim()},f=e=>{let t=t=>e.next(t),n=t=>e.throw(t);return new Promise(((i,o)=>{let a=e=>{e.done?i(e.value):Promise.resolve(e.value).then(t,n).then(a,o)};a(e.next())}))};let g;const m=document.getElementById("comments-issue-id").innerText,n=new URL(window.location.href);let q,p=n.searchParams.get("github_access_token");p&&(document.cookie=`github_access_token=${p};Path=/;Secure;SameSite=Strict`,n.searchParams.delete("github_access_token"),window.location.replace(n)),null!=p||(p=null==(q=document.cookie.split(";").find((e=>e.trim().startsWith("github_access_token="))))?void 0:q.trim().substring(20));const r=()=>{document.cookie="github_access_token=;expires=Thu, 01 Jan 1970 00:00:00 GMT;Path=/;Secure;SameSite=Strict",p=null},t=()=>f(function*(){var e;let n;if(g=JSON.parse(null!=(n=null==(e=document.getElementById("comments-addition"))?void 0:e.innerText)?n:"[]"),p){if(200!==(e=yield fetch(`https://comments.eaimty.com/comments?issue_id=${m}&github_access_token=${p}`,{method:"GET"})).status)return r(),yield t()}else e=yield fetch(`https://comments.eaimty.com/comments?issue_id=${m}`,{method:"GET"});200===e.status&&(g=g.concat(yield e.json()))}()),u=()=>{g.sort(((e,t)=>new Date(e.created_at).getTime()-new Date(t.created_at).getTime()));let e=document.getElementById("comment-list");e.innerHTML="";var t=document.createElement("div");for(t.id="comment-header",t.innerText="Comments",e.appendChild(t),0===g.length&&((t=document.createElement("div")).id="comment-tip",t.innerText="No comment yet",e.appendChild(t)),t=0;t<g.length;t++){let o=document.createElement("li");var n=document.createElement("div");n.id="comment-info";var i=document.createElement("img");i.id="comment-avatar",i.src=g[t].user.avatar_url,n.appendChild(i),(i=document.createElement("a")).id="comment-author",i.innerText=g[t].user.login,g[t].user.html_url&&(i.href=g[t].user.html_url),n.appendChild(i),(i=document.createElement("div")).id="comment-datetime",i.innerText=new Date(g[t].created_at).toLocaleString(),n.appendChild(i),o.appendChild(n),(n=document.createElement("div")).id="comment-body",n.innerHTML=y(g[t].body),o.appendChild(n),e.appendChild(o)}},v=()=>f(function*(){let e=document.getElementById("comment-action");e.innerHTML="";var n=document.createElement("div");if(n.id="comment-header",n.innerText="Leave a comment",e.appendChild(n),p){if(200===(n=yield fetch(`https://comments.eaimty.com/userinfo?github_access_token=${p}`,{method:"GET"})).status){n=yield n.json();let o=document.createElement("div");o.id="comment-action-info";var i=document.createElement("img");i.id="comment-action-avatar",i.src=n.avatar_url,o.appendChild(i),(i=document.createElement("a")).id="comment-action-author",i.innerText=n.login,i.href=n.html_url,o.appendChild(i);let a=document.createElement("button");a.id="comment-action-logout",a.innerText="Logout",a.addEventListener("click",(()=>{r(),v()})),o.appendChild(a),e.appendChild(o),(n=document.createElement("div")).id="comment-tip",n.innerText="Before commenting, please think about whether your comment is meaningful? Is it related to the topic? Is it rational and friendly? If you were someone else, would you feel uncomfortable seeing this comment?",e.appendChild(n),(n=document.createElement("div")).id="comment-action-input";let c=document.createElement("textarea");c.id="comment-action-textarea",c.placeholder="Leave a comment",n.appendChild(c);let l=document.createElement("button");return l.id="comment-action-post",l.innerText="Comment",l.addEventListener("click",(()=>f(function*(){a.disabled=!0,c.disabled=!0,l.disabled=!0;let e=c.value.trim();0!==e.length&&(201===(yield fetch(`https://comments.eaimty.com/comments?issue_id=${m}&github_access_token=${p}`,{method:"POST",body:JSON.stringify({body:e})})).status?t().then((()=>u())).then((()=>v())):(r(),yield v(),window.alert("Failed to post comment")))}()))),n.appendChild(l),void e.appendChild(n)}r()}(n=document.createElement("div")).id="comment-tip",n.innerText="Clicking the login button means you agree to use cookies to store your GitHub Access Token",e.appendChild(n),(n=document.createElement("button")).id="comment-action-login",n.innerText="Login with GitHub",n.addEventListener("click",(()=>window.location.replace(`https://comments.eaimty.com/login?redirect_uri=${window.location.href}`))),e.appendChild(n)}());t().then((()=>u())).then((()=>v()))</script></div>